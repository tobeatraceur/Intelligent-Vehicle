/********************************************Copyright******************************************************
**                                                                                                      
**
**-------------------------------------------文件信息-------------------------------------------------------
** 文件名称:			Wp_25F16.c
** 最后修订日期:  		2012-10-10
** 最后版本:			1.0
** 描述:				片外FLASH文件操作;
**
**-----------------------------------------------------------------------------------------------------------
** 创建人:				吴康
** 创建日期:			2012-02-09
** 版本:				1.0
** 描述:				片外FLASH文件操作;
**
**-----------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
** 版本:
** 描述:
**
**-----------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
** 版本:
** 描述:
**
*************************************************************************************************************/
#include "Wp_25F16.h"


/*************************************************************************************************************
** 函数名称:			SPIByte
**
** 函数描述:			读写SPI总线;
** 						对于SPI来说，主机的读也需要先写;
**					    使用此函数，读的时候建议参数设置为0xff，写的时候则写参数;
**                      这里使用直接操作寄存器的办法实现SPI硬件层读写,是为了加快速写速度;
**
** 输入变量:			u8 byte;
** 返回值:				u8;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static u8 SPIByte(u8 byte)
{
	/*  等待发送寄存器空    */
	while((SPI2->SR & SPI_I2S_FLAG_TXE) == RESET);
    /*发送一个字节*/
	SPI2->DR = byte;
    
	/*  等待接收寄存器有效  */
	while((SPI2->SR & SPI_I2S_FLAG_RXNE) == RESET);
    
	return (SPI2->DR);
}


/*************************************************************************************************************
** 函数名称:			SSTCmd1
**
** 函数描述:		    SSTCmd1/2/4;
** 						写一个SST命令/写一个命令后接一个数据/写一个命令后再写3个数据;
**					    这是一个完整的单命令操作，不返回;
** 输入变量:			u8 cmd;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static void SSTCmd1(u8 cmd)
{
	SST_SELECT();
    
	SPIByte(cmd);
    
	SST_DESELECT();
}


/*************************************************************************************************************
** 函数名称:			SSTCmd2
**
** 函数描述:		    
** 						
**					    
** 输入变量:			u8 cmd, u8 data;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static void SSTCmd2(u8 cmd, u8 data)
{
	SST_SELECT();
    
	SPIByte(cmd);                   // 首命令
	SPIByte(data);                  // 写一个数据
    
	SST_DESELECT();
}


/*************************************************************************************************************
** 函数名称:			SSTCmd4
**
** 函数描述:		    
** 						
**					    
** 输入变量:			u8 cmd, u8 *addr;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
/*static void SSTCmd4(u8 cmd, u8 *addr)
{
	SST_SELECT();
    
	SPIByte(cmd);	                // 首命令
	SPIByte(*addr++);               // 写三个数据
	SPIByte(*addr++);
	SPIByte(*addr);
    
	SST_DESELECT();
}
*/

/*************************************************************************************************************
** 函数名称:			SSTCmdb1b
**
** 函数描述:		    SSTCmdb1b/SSTCmd4bsl;
** 						写一个SST命令，返回1字节数据/写1个命令字，3个地址字，返回多个字节;
**					    
** 输入变量:			u8 cmd;
** 返回值:				u8;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static u8 SSTCmdb1b(u8 cmd)
{
	u8 tmp = 0;
    
	SST_SELECT();
    
	SPIByte(cmd);
	tmp = SPIByte(0xff);
    
	SST_DESELECT();
    
	return (tmp);
}


/*************************************************************************************************************
** 函数名称:			SSTCmd4bs
**
** 函数描述:		    
** 						
**					    
** 输入变量:			u8 cmd, u8* addr, u8* data, u32 no;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static void SSTCmd4bs(u8 cmd, u8* addr, u8* data, u32 no)
{
	SST_SELECT();
    
	SPIByte(cmd);	                        // 首命令
	SPIByte(*addr++);
	SPIByte(*addr++);
	SPIByte(*addr);
    
	for(; no > 0; no--)
	{
		*data++ = SPIByte(0xff);
	}
    
	SST_DESELECT();
}


/*************************************************************************************************************
** 函数名称:			SST25WREN
**
** 函数描述:		    允许写功能;
** 						
**					    
** 输入变量:			void;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
/*static void SST25WREN(void)
{
	SSTCmd1(0x06);                  // 0x06为Write-Enable指令
}
*/

/*************************************************************************************************************
** 函数名称:			SST25WRDI
**
** 函数描述:		    屏蔽写功能;
** 						
**					    
** 输入变量:			void;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static void SST25WRDI(void)
{
	SSTCmd1(0x04);                  // 0x04为Write-Disable指令
}


/*************************************************************************************************************
** 函数名称:			SST25BY
**
** 函数描述:		    检测忙;
** 						0x01为忙状态，0x00为非忙状态;
**					    忙状态表示芯片内部写操作正在进行;
** 输入变量:			void;
** 返回值:				u8;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static u8 SST25BY(void)
{
	u8 sta = 0;
    
	sta = SSTCmdb1b(0x05);          // 读状态寄存器
    
	return (sta & 0x01);            // bit0为忙状态位
}


/*************************************************************************************************************
** 函数名称:			SST25WPEN
**
** 函数描述:		    允许软件写保护;
** 						SST25的写入比较繁琐，建议在每次操作前都取消掉写保护，操作完成后则重新允许写保护;
**					    
** 输入变量:			void;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static void SST25WPEN(void)
{
	u8 sta = 0;
    
	sta = SSTCmdb1b(0x05) | 0x1c;		// 读出寄存器并加入保护位
	SSTCmd1(0x50);					    // 允许写，x050为Enable-Write-Status-Register指令
	SSTCmd2(0x01, sta);
}


/*************************************************************************************************************
** 函数名称:			SST25WriteEn
**
** 函数描述:		    先消除保护位，再允许写位;
** 						
**					    
** 输入变量:			void;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
static void SST25WriteEn(void)
{
	u8 sta = 0;
    
	sta = SSTCmdb1b(0x05) & (~0x1c);    // 读出寄存器并消除保护位
	SSTCmd1(0x50);					    // 允许写寄存器，使能写状态寄存器
	SSTCmd2(0x01, sta);				    // 写寄存器
	SSTCmd1(0x06);					    // 允许写，写使能
}


/*************************************************************************************************************
** 函数名称:			SST25ReadID
**
** 函数描述:		    读取SST的ID;
** 						读取数据为BF41，其中0xBF为制造商ID，0x41为器件ID;
**					    
** 输入变量:			void;
** 返回值:				u16;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
u16 SST25ReadID(void)
{
	u8 id[3] = {0, 0, 0};                   // ID缓存
	u8 addr[3] = {0, 0, 0};                 // 地址缓存，0x00 0x00 0x00返回0xBF41，0x00，0x00，0x01返回0x41BF
	
	SSTCmd4bs(0x90, addr, id, 3);           // 0x90读ID命令
    
	return ((id[0] << 8) + id[1]);          // 返回0xBF41
}


/*************************************************************************************************************
** 函数名称:			SST25ChipErase
**
** 函数描述:		    刷除CHIP;
** 						
**					    
** 输入变量:			void;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
void SST25ChipErase(void)
{
	SST25WriteEn();
    
	SSTCmd1(0x60);              // 0x60为Chip-Erase指令
	while(SST25BY());           // 等待内部写操作结束
    
	SST25WPEN();
}


/*************************************************************************************************************
** 函数名称:			SST25SectorErase
**
** 函数描述:		    刷扇区;
** 						
**					    
** 输入变量:			void;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
void SST25SectorErase(u32 addr)
{
	u8 ad[3] = {0, 0, 0};
    
	ad[0] = (addr >> 16) & 0xff;
	ad[1] = (addr >> 8) & 0xff;
	ad[2] = addr & 0xff;
	
	SST25WriteEn();
	
	SST_SELECT();
	SPIByte(0x20);
	SPIByte(ad[0]);
	SPIByte(ad[1]);
	SPIByte(ad[2]);
	SST_DESELECT();
	
	while(SST25BY());
//	SST25WPEN();
}


/*************************************************************************************************************
** 函数名称:			SST25ByteProgram
**
** 函数描述:		    写一个字节;
** 						注意在此前要调用取消写保护,实际写应使用AAI,此函数在AAI中调用，用于写奇数个字节;
**					    
** 输入变量:			u32 addr, u8 byte;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
void SST25ByteProgram(u32 addr, u8 byte)
{
	u8 ad[3] = {0, 0, 0};
    
	ad[0] = (addr >> 16) & 0xff;
	ad[1] = (addr >> 8) & 0xff;
	ad[2] = addr & 0xff;
    
	SST_SELECT();
    
	SPIByte(0x02);
	SPIByte(ad[0]);
	SPIByte(ad[1]);
	SPIByte(ad[2]);
	SPIByte(byte);
    
	SST_DESELECT();
    
	while(SST25BY());
}


/*************************************************************************************************************
** 函数名称:			SST25Write
**
** 函数描述:		    写多个字节;
** 						
**					    
** 输入变量:			u32 addr, u8* p_data, u32 no;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
void SST25Write(u32 addr, u8* p_data, u32 no)
{
	u8 ad[3] = {0, 0, 0};
	u32 cnt = 0;
    
	if (no == 0)
		return;
		
	SST25WriteEn();
	
	if (no == 1)	                            // no<2则应使用普通单字节方式
	{
		SST25ByteProgram(addr, *p_data);
	//	SST25WPEN();
	}
	else
	{
		cnt = no;
		
		ad[2] = (addr>>16) & 0xff;
		ad[1] = (addr>>8) & 0xff;
		ad[0] = addr & 0xff;
		
		SST_SELECT();
		SPIByte(0xad);
		SPIByte(ad[2]);
		SPIByte(ad[1]);
		SPIByte(ad[0]);
		SPIByte(*p_data++);
		SPIByte(*p_data++);
		SST_DESELECT();
		cnt -= 2;
		while(SST25BY());                       // 判忙
		
		// 中间的双字节写
		for (; cnt > 1; cnt -= 2)
		{
			SST_SELECT();
            
			SPIByte(0xad);
			SPIByte(*p_data++);
			SPIByte(*p_data++);
            
			SST_DESELECT();
			while(SST25BY());                   // 判忙
		}
		SST25WRDI();                            // WRDI用于退出AAI写模式
		
		// 如果有最后一个字节(no为奇数）
		if (cnt == 1)
		{
			SST25WriteEn();
			SST25ByteProgram(addr + no - 1, *p_data);
		}
	}
	SST25WPEN();                                // WP保护
}


/*************************************************************************************************************
** 函数名称:			SST25Read
**
** 函数描述:		    高速读，对于后续带5的芯片，可调用此函数读;
** 						
**					    
** 输入变量:			u32 addr, u8* p_data, u32 no;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
void SST25Read(u32 addr, u8* p_data, u32 no)
{
	SST_SELECT();

	SPIByte(0x0b);
	SPIByte(addr >> 16);
	SPIByte(addr >> 8);
	SPIByte(addr);
	SPIByte(0xff);

	for (; no > 0; no--)
    {
        *p_data++ = SPIByte(0xff);
    }
    
	SST_DESELECT();
}


/*************************************************************************************************************
** 函数名称:			SST25ReadL
**
** 函数描述:		    低速读;
** 						
**					    
** 输入变量:			u32 addr, u8* p_data, u32 no;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
void SST25ReadL(u32 addr, u8* p_data, u32 no)
{
	u8 ad[3] = {0, 0, 0};
    
	ad[2] = (addr >> 16) & 0xff;
	ad[1] = (addr >> 8) & 0xff;
	ad[0] = addr & 0xff;
	
	SSTCmd4bs(0x03, ad, p_data, no);
}


//u16 id;

//测试SST,先全部刷除,再逐个写入数据检查--这样时间太长了,改为只写入检测128字节数据
void TestSst(void)
{
//  u16 id = 0;
	u8 i = 0;
	u32 addr = 0;
	u8 db_sst1[64];
    
//	exflashid = SST25ReadID();
//	exflashid = SST25ReadID();
	exflashid = SST25ReadID();
	
	// 刷除扇区并校验是否刷除成功
	SST25SectorErase(1);
	for(addr = 0; addr < 64; addr += 64)
	{
		SST25Read(addr, db_sst1, 64);                   // 读64个字节
		for(i = 0; i < 64; i++)
		{
			if (db_sst1[i] != 0xff)                     // 扇区一个字节默认为0xff
			{
			//	Wp_Usart1_SendStr("25FLASH检查出错\r\n");
				while(1);
			}
		}
	}
	
	// 写入一个扇区并校验是否成功
	for(i = 0; i < 64; i++)
    {
		db_sst1[i] = i;
    }
    
	// 写入一个扇区,一个扇区是4K,也就是64*64
	for(addr = 0; addr < 64; addr += 64)
	{
		SST25Write(addr, db_sst1, 64);                  // 写入64个字节
		SST25Read(addr, db_sst1, 64);                   // 读64个字节
		for(i = 0; i < 64; i++)
		{
			if (db_sst1[i] != i)
			{
			//	Wp_Usart1_SendStr("25FLASH检查出错\r\n");
				while(1);
			}
		}
	}
    
//	Wp_Usart1_SendStr("25FLASH检查完成\r\n");
}


/*************************************************************************************************************
** 函数名称:			Wp_TurnToSST25
**
** 函数描述:		    返回串行FLASH模式;
** 						
**					    
** 输入变量:			void;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
void Wp_TurnToSST25(void)
{
	u8 i = 0;
    
	Wp_FlashSpiConfigure();
    
	for (i = 0; i < 8; i++)
    {
		SPIByte(0xff);	            // 复位总线
    }
}


/*************************************************************************************************************
** 函数名称:			Wp_FlashSpiConfigure
**
** 函数描述:			初始化片外串行FLASH的SPI接口;
** 						
**					    
** 输入变量:			void;
** 返回值:				void;
**
** 使用宏或常量:		None;
** 使用全局变量:		None;
**
** 调用函数:			None;
**
** 创建人:				
** 创建日期:			2011-11-1
**-------------------------------------------------------------------------------------------------------------
** 修订人:
** 修订日期:
**-------------------------------------------------------------------------------------------------------------
***************************************************************************************************************/
void Wp_FlashSpiConfigure(void)
{
    SPI_InitTypeDef SPI_InitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
    
    /* PB13-SCK, PB15-MOSI  */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_15;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;                         // 推挽复用输出
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    
    /*  PB14-MISO    */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;                   // 浮空输入
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    
    /*  PB12作为片选    */
	GPIO_SetBits(GPIOB, GPIO_Pin_12);                                       // 片选信号预置为高
    
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;                        // 推挽输出
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    
    /*  SPI2 configuration  */
	SPI_Cmd(SPI2, DISABLE); 												// 必须先禁能,才能改变MODE
    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;		// 两线全双工
    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;							// 主
    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;						// 8位
    SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;								// CPOL=0 时钟悬空低
    SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;							// CPHA=0 数据捕获第1个
    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;								// 软件NSS
    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;		// 2分频=36M
    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;						// 高位在前
    SPI_InitStructure.SPI_CRCPolynomial = 7;								// CRC7
    
	SPI_Init(SPI2, &SPI_InitStructure);
//  SPI_SSOutputCmd(SPI2, ENABLE);                                          // 使能NSS脚可用
    SPI_Cmd(SPI2, ENABLE);
}


/********************************************************************************************************
**                            End Of File
********************************************************************************************************/
